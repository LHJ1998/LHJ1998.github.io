<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-抽象工厂模式]]></title>
    <url>%2F2019%2F08%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式-抽象工厂模式 &ensp;&ensp;&ensp;&ensp;工厂方法模式虽然可以通过创建对应的工厂实例简化代码，但是无论是工厂方法模式还是简单工厂模式，都有一个问题就是：只能够创建一类事物，比如之前写的创建图形验证码，那么就不可能去创建邮件验证码、短信验证码等。 &ensp;&ensp;&ensp;&ensp;换一个例子，如果使用工厂方法模式来实现空调和冰箱的创建，那么就需要两个工厂，但是市面上有很多的品牌，如海尔和美的，海尔的工厂创建出来的是海尔空调或海尔冰箱，而美的工厂创建出来的就是美的空调和美的冰箱，如果是工厂方法模式，这里就需要有四个工厂：海尔空调工厂、海尔冰箱工厂、美的空调工厂、美的冰箱工厂。这个例子说明了工厂方法模式的一个弊端就是：只可以创建一类事物，而不能创建一族事物 定义抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 模式结构&ensp;&ensp;&ensp;&ensp;抽象工厂模式包含以下几个对象: 1.抽象产品，定义唱片的共有属性和方法 2.具体产品，定义产品的特有属性和方法 3.抽象工厂，定义工厂的公共方法 4.具体工厂，定义工厂方法的具体实现 代码示例123456789package com.lhj8023.design.pattern;public abstract class AirCondition &#123; protected double price; protected abstract void show();&#125; 123456789package com.lhj8023.design.pattern;public abstract class Refrigerator &#123; protected double price; protected abstract void show();&#125; 123456789package com.lhj8023.design.pattern;public abstract class Factory &#123; protected abstract AirCondition createAirCondition(); protected abstract Refrigerator createRefrigerator();&#125; 12345678package com.lhj8023.design.pattern;public class HaierAirCondition extends AirCondition &#123; @Override protected void show() &#123; System.out.println("海尔空调"); &#125;&#125; 12345678package com.lhj8023.design.pattern;public class HaierRefrigerator extends Refrigerator &#123; @Override protected void show() &#123; System.out.println("海尔电冰箱"); &#125;&#125; 12345678910111213package com.lhj8023.design.pattern;public class HaierFactory extends Factory &#123; @Override protected AirCondition createAirCondition() &#123; return new HaierAirCondition(); &#125; @Override protected Refrigerator createRefrigerator() &#123; return new HaierRefrigerator(); &#125;&#125; 123456789package com.lhj8023.design.pattern;public class MediAirCondition extends AirCondition &#123; @Override protected void show() &#123; System.out.println("美的空调..."); &#125;&#125; 12345678package com.lhj8023.design.pattern;public class MediRefrigerator extends Refrigerator &#123; @Override protected void show() &#123; System.out.println("美的电冰箱..."); &#125;&#125; 12345678910111213package com.lhj8023.design.pattern;public class MeidiFactory extends Factory &#123; @Override protected AirCondition createAirCondition() &#123; return new MediAirCondition(); &#125; @Override protected Refrigerator createRefrigerator() &#123; return new MediRefrigerator(); &#125;&#125; 抽象工厂模式的优点1.抽象工厂模式也是屏蔽了实现细节，客户端只需要负责消费即可，不需要知道具体的实现细节 2.可以实现一个产品族的生产，而不是一类产品 抽象工厂模式的缺点1.如果有新的产品对象不易添加，因为抽象工厂方法都已经写好了，如果添加新的产品，就需要改动抽象工厂，然后其它具体工厂的实现也要改]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法模式]]></title>
    <url>%2F2019%2F08%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式-工厂方法模式 &ensp;&ensp;&ensp;&ensp;之前的 设计模式-简单工厂模式 有一个弊端：工厂提供静态方法，扩展不易，而且所有的创建对象的方法集中在一个工厂里面，如果对象实例很多，那么维护起来就很麻烦。工厂方法模式就是一个工厂创建一种实例，把不同的实例的创建过程分配到特定的工厂里去，便于维护。 定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 模式结构&ensp;&ensp;&ensp;&ensp;工厂方法模式包含以下几个角色: 1.Product:抽象产品，定义产品的共有属性和方法 2.ConcreteProduct:具体产品，定义产品的具体内容 3.Factory:抽象工厂，定义工厂的创建方法接口 4.ConcreteFactory:具体工厂，实现具体创建实例的方法 代码示例12345678910111213package com.lhj8023.design.pattern;public abstract class Captcha &#123; protected String format; protected Integer width; protected Integer height; protected abstract void show();&#125; 1234567package com.lhj8023.design.pattern;public abstract class CaptchaFactory &#123; protected abstract Captcha createCaptcha();&#125; 123456789package com.lhj8023.design.pattern;public class GIFCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a GIF Captcha"); &#125;&#125; 12345678910package com.lhj8023.design.pattern;public class GIFFactory extends CaptchaFactory &#123; @Override protected Captcha createCaptcha() &#123; return new GIFCaptcha(); &#125;&#125; 12345678910package com.lhj8023.design.pattern;public class JPGCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a JPG Captcha"); &#125;&#125; 12345678package com.lhj8023.design.pattern;public class JPGFactory extends CaptchaFactory &#123; @Override protected Captcha createCaptcha() &#123; return new JPGCaptcha(); &#125;&#125; 12345678910package com.lhj8023.design.pattern;public class PNGCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a PNG Captcha"); &#125;&#125; 12345678package com.lhj8023.design.pattern;public class PNGFactory extends CaptchaFactory &#123; @Override protected Captcha createCaptcha() &#123; return new PNGCaptcha(); &#125;&#125; 工厂方法模式优点1.工厂方法模式和简单工厂模式一样，对客户端隐藏了实现细节，客户端无需关心实现细节，只需要知道具体是哪个工厂创建对应的实例即可。 2.工厂方法模式的实现的关键是面向对象的多态性，通过多态，使工厂对同一消息做出了不同的反应 3.如果添加了新的产品，只需要添加对应的产品类和对应的工厂类就可以了，而不用去修改原来的工厂 工厂方法模式的缺点1.如果实例比较多，那么就需要创建很多的具体工厂，增加了系统的复杂度。需要加载的类也增多，加大了系统的开销]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂模式]]></title>
    <url>%2F2019%2F08%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式-简单工厂模式 &ensp;&ensp;&ensp;&ensp;考虑这么一种场景，假设现在有很多种验证码图片的格式，比如GIF、PNG、JPG等，这些验证码都来自于同一个基类，不同之处在于他们修改了基类的部分属性，使得呈现出来的效果不同。那么假如希望在使用这些验证码格式的时候，不需要知道具体的验证码的类型，而是通过传递一些参数到一个方法里面，然后这个方法就可以返回一个对应格式的验证码对象。这样的方法就是`简单工厂模式` 定义简单工厂模式属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 # 模式结构 简单工厂模式包含以下几个角色： 1.Factory：工厂角色，负责创建所有的实例，内部实现所有实例的实现方法 2.Product：抽象产品角色，抽象产品角色是所有产品的抽象描述，定义产品的共有属性和方法 3.ConcreteProduct：具体产品角色，拥有明确定义的产品，包括了抽象产品角色的共有属性和方法以及自己的特有属性和方法 代码示例12345678910111213141516package com.lhj8023.design.pattern;public class CaptchaFactory &#123; public static Captcha createCaptcha(String format)&#123; if("gif".equals(format))&#123; return new GIFCaptcha(); &#125;else if("png".equals(format))&#123; return new PNGCaptcha(); &#125;else if("jpg".equals(format))&#123; return new JPGCaptcha(); &#125; return null; &#125;&#125; 12345678910111213package com.lhj8023.design.pattern;public abstract class Captcha &#123; protected String format; protected Integer width; protected Integer height; protected abstract void show();&#125; 123456789package com.lhj8023.design.pattern;public class GIFCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a GIF Captcha"); &#125;&#125; 12345678910package com.lhj8023.design.pattern;public class PNGCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a PNG Captcha"); &#125;&#125; 12345678910package com.lhj8023.design.pattern;public class JPGCaptcha extends Captcha &#123; @Override protected void show() &#123; System.out.println("this is a JPG Captcha"); &#125;&#125; 简单工厂模式的优点1.客户端无需知道具体的是哪一个类，只需要传递对应的参数就可以获取到对应的产品，简单工厂模式做到了责任分割，客户端无需创建对象，只需要消费即可。 简单工厂模式的缺点1.简单工厂模式集中了所有的对象创建的方法，因此如果简单工厂不能正常运行，会导致整个系统无法正常运行 2.扩展困难，如果有新的产品或者产品，就需要修改源代码，违背开闭原则。产品类型如果很多，那么简单工厂的时间就比较复杂，可读性差 3.简单工厂模式使用的静态方法，造成工厂角色无法拥有继承等级结构 适用环境1.需要创建的产品比较少，这样简单工厂就不需要有太多的创建实例的方法，易于维护 2.客户端只关心传入的参数，并不关心创建的过程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看懂UML图]]></title>
    <url>%2F2019%2F08%2F30%2F%E7%9C%8B%E6%87%82UML%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[看懂UML图 # 一个简单的示例 先通过一个简单的UML类图示例，更好的理解内容 图中一共有六种关系，分别是 1.实现关系，如小汽车和自行车，是抽象类的两个实现类，使用虚线空心箭头表示 2.继承关系，如SUV继承自小汽车，是小汽车的一个子类，使用实线空心箭头表示 3.组合关系，如小汽车就是由轮胎和发动机组合的，使用实线实心菱形表示 4.聚合关系，如班级包含了许多的学生，和学生构成聚合关系，使用实线空心菱形表示 5.依赖关系，如学生上学需要使用自行车，和自行车构成依赖关系，使用虚线箭头表示 6.关联关系，如学生拥有身份证，身份证和学生一一对应，是关联关系，使用实线表示 类与类之间的关系参考： https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#id1]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java三种代理模式]]></title>
    <url>%2F2019%2F08%2F27%2FJava%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JAVA三种代理模式 本文内容包括 1.静态代理 2.JDK动态代理 3.CGLIB代理 什么是代理模式&ensp;&ensp;&ensp;&ensp;代理模式就是为需要访问的对象提供了一个代理，通过代理对象访问。这么说有点抽象，举例来说就比如买火车票，在网络没有普及的时候，会选择去火车站买，现在一般是在同城艺龙、12306、智行等等软件上面购买。那么同城艺龙、12306、智行这些就相当于火车站的售票代理，通过售票代理买到火车票而不用找火车站买 &ensp;&ensp;&ensp;&ensp;代理模式在程序中很普遍，例如Spring框架里面的AOP，其原理就是代理模式。根据类创建的时机不同，代理模式可以分为静态代理和动态代理：在程序运行前就已经编译生成好的类是静态代理，在程序运行期间动态生成的类是动态代理。 代理模式UML类图 代理对象的作用1.拦截对真实对象的访问 &ensp;&ensp;&ensp;&ensp;这个很好理解，代理模式就是让你访问代理对象，而不去找目标对象。通过这种方式可以忽略目标对象的实现细节，访问目标对象前进行一些 其它的操作 2.代理对象是对目标对象的增强 &ensp;&ensp;&ensp;&ensp;既然是通过代理对象访问的目标对象，那么可以在访问目标对象之前进行方法增强，例如打印日志或者进行其它的前置或者后置处理等。例如超市是商品的一个代理对象，超市可以通过一系列的活动进行商品促销（方法增强），但是原产地（目标对象）只是生产商品，并不会有促销的功能。 正文前的一些约定 1.售票抽象类 1234567package com.lhj8023.proxy;public interface SaleTicket &#123; void sale();&#125; 2.售票实现类 12345678package com.lhj8023.proxy;public class SaleTicketImpl implements SaleTicket &#123; @Override public void sale() &#123; System.out.println("sale a ticket"); &#125;&#125; 静态代理&ensp;&ensp;&ensp;&ensp;在这之前，假如说有这么一种需求，需要查看售出一张票的时间，就是打印一下售票的时间。那么可以这么做 1234567891011package com.lhj8023.proxy;public class SaleTicketImpl implements SaleTicket &#123; @Override public void sale() &#123; long start = System.currentTimeMillis(); System.out.println("sale a ticket"); long end = System.currentTimeMillis(); System.out.println("spend time: " + (end - start)); &#125;&#125; &ensp;&ensp;&ensp;&ensp;这是在有源代码的情况下，但是如果没有源代码呢或者要求不可以改原来的实现呢 12345678910111213package com.lhj8023.proxy;public class Main &#123; public static void main(String[] args) &#123; SaleTicket saleTicket = new SaleTicketImpl(); long start = System.currentTimeMillis(); saleTicket.sale(); long end = System.currentTimeMillis(); System.out.println("spend time: " + (end - start)); &#125; &#125; 这种方法是在执行的时候先包上一层膜，虽然可以达到效果，但是看起来就很臃肿，如果是一次要执行两次sale，然后分别打印时间呢，那就要复制一份咯，看起来就更丑更傻了… &ensp;&ensp;&ensp;&ensp;另一种方法就是通过静态代理了，先看代码 123456789101112131415161718package com.lhj8023.proxy;public class SaleTicketStaticProxy implements SaleTicket &#123; private SaleTicket target; public SaleTicketStaticProxy(SaleTicket target)&#123; this.target = target; &#125; @Override public void sale() &#123; long start = System.currentTimeMillis(); target.sale(); long end = System.currentTimeMillis(); System.out.println("spend time: " + (end - start)); &#125;&#125; &ensp;&ensp;&ensp;&ensp;静态代理实现了和被代理类一样的接口，然后内部维护一个被代理类，通过代理类间接的访问了被代理类，而且在访问之前做了增强。而且调用多次的话可以重用这一层增强，不会难看也不会冗余，舒服多了 小结：静态代理实现方式就是预先创建一个代理类，在代理类中维护被代理类，而且实现和被代理类相同的接口或者继承相同的类。因为是预先就已经写好的，在编译的时候就会生成的类，因此是静态的。静态代理有一个很明显的缺点就是：如果接口改了，除了实现类要改，代理类也要跟着改，维护起来很麻烦 动态代理&ensp;&ensp;&ensp;&ensp;动态代理分为JDK动态代理和CGLIB动态代理，这两个的区别在于，JDK动态代理需要被代理类实现接口，而CGLIB代理不需要 JDK动态代理&ensp;&ensp;&ensp;&ensp;JDK动态代理就是通过Proxy.newProxyInstance获得一个目标对象的代理对象，然后通过生成代理对象的InvocationHandler对要执行的方法进行增强，达到代理的效果 1234567891011121314151617181920212223242526package com.lhj8023.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class SaleTicketProxyFactory &#123; //被代理对象 private Object target; public SaleTicketProxyFactory(Object target)&#123; this.target = target; &#125; public Object getProxyInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123; long start = System.currentTimeMillis(); method.invoke(target, args); long end = System.currentTimeMillis(); System.out.println("spend time: " + (end - start)); return null; &#125;); &#125;&#125; 123456789101112package com.lhj8023.proxy;public class Main &#123; public static void main(String[] args) &#123; SaleTicket saleTicket = new SaleTicketImpl(); SaleTicketProxyFactory factory = new SaleTicketProxyFactory(saleTicket); SaleTicket proxy = (SaleTicket) factory.getProxyInstance(); proxy.sale(); &#125;&#125; &ensp;&ensp;&ensp;&ensp;不过从这里似乎看不出来为什么JDK代理要求目标对象必须实现接口。如果对proxy对象进行反编译，就可以得到proxy对象的结构了 123public final class $Proxy0 extends Proxy implements SaleTicket &#123; //...&#125; &ensp;&ensp;&ensp;&ensp;从这里就可以看出来为什么JDK动态代理必须实现接口了，因为proxy对象继承了Proxy类，而JAVA中是不允许多继承的，因此代理对象就必须实现接口，否则就无法获得目标对象有哪些方法 CGLIB代理&ensp;&ensp;&ensp;&ensp;CGLIB代理和JDK代理不同，CGLIB不需要目标对象实现接口，但是目标对象必须有一个无参的构造函数 12345678910111213141516171819202122232425262728293031323334package com.lhj8023.proxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxyFactory implements MethodInterceptor &#123; //维护一个目标对象 private Object target; public CglibProxyFactory(Object target)&#123; this.target = target; &#125; public Object getProxyInstance()&#123; //增强器 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; long start = System.currentTimeMillis(); method.invoke(target, args); long end = System.currentTimeMillis(); System.out.println("spend time: " + (end - start)); return null; &#125;&#125; 123456789101112package com.lhj8023.proxy;public class Main &#123; public static void main(String[] args) &#123; SaleTicket saleTicket = new SaleTicketImpl(); CglibProxyFactory factory = new CglibProxyFactory(saleTicket); SaleTicket proxy = (SaleTicket) factory.getProxyInstance(); proxy.sale(); &#125;&#125; &ensp;&ensp;&ensp;&ensp;同样的，对proxy对象反编译以后，就知道为什么目标对象必须有无参构造方法了 1234public class SaleTicket$$EnhancerByCGLIB$$4da4ebaf extends SaleTicket implements Factory &#123; //... &#125; &ensp;&ensp;&ensp;&ensp;生成的代理对象里面，是继承了目标对象，那么代理对象就是目标对象的子类，实例化子类的时候是需要实例化父类的，这里不可能给出实例化父类需要的参数，因此被代理的目标对象就必须要有无参构造方法，否则是不能代理的 小结：JDK动态代理和CGLIB代理大同小异，其原理都是通过对目标对象进行一层包装，执行方法前经过这些包装达到增强的效果，只不过JDK动态代理需要目标对象实现接口，CGLIB要求必须要有无参构造函数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>Java</tag>
        <tag>静态代理</tag>
        <tag>JDK代理</tag>
        <tag>CGLIB代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题美化]]></title>
    <url>%2F2019%2F08%2F26%2FHexo-Next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Hexo Next主题美化 本文内容包括 1.Next 主题安装 2.Next 主题基本配置 3.Next 主题美化 Next 主题安装在博客的根目录下，打开bash执行以下语句 1git clone https://github.com/theme-next/hexo-theme-next themes/next 或者 1git clone https://github.com/iissnan/hexo-theme-next.git themes/next 不过似乎iissnan不再维护了，所以这里采用的是第一种方法 Next 主题基本配置站点的_config.yml配置 主要是对站点进行基本的配置和应用next主题 Site 配置 配置个人站点的信息，如站点名、子标题、个人描述、站点关键字、作者、语言等信息 12345678# Sitetitle: #站点名subtitle: #子标题description: #个人描述keywords: #站点关键字author: #作者language: #站点语言显示 zh-CN | entimezone: #时区 URL 配置 主要配置自己博客的地址 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: #博客地址root: / #根目录permalink: #生成博客的路径 默认是:year/:month/:day/:title/permalink_defaults: Deployment 配置 写好博客以后，需要部署到服务器上，在这里配置仓库地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: #提交类型 我用的github，这里填的git repo: #代码仓库 branch: #提交的分支 默认是master 配置好了以后还不可以提交，需要再安装一个插件（针对git而言的） 1$ npm install hexo-deployer-git --save 如果要配置其它仓库的话，参考官网配置 应用Next主题下载了主题，需要让hexo应用这个主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #应用的主题 默认为landscape 主题的_config.yml配置站点图标配置 配置站点的图标，本地运行看不出效果，需要部署到服务器上才看得到 1234567favicon: small: /images/favicon-16x16.ico medium: /images/favicon-32x32.ico #apple_touch_icon: /images/apple-touch-icon-next.png #safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 页脚设置 可以关闭页脚的主题信息 12345678910111213141516171819202122232425262728293031323334353637383940footer: counter: true # Specify the date when the site was setup. If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: # Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, `author` from Hexo `_config.yml` will be used. copyright: powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: true # Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn beian: enable: false icp: # The digit in the num of gongan beian. gongan_id: # The full num of gongan beian. gongan_num: # The icon for gongan beian. See: http://www.beian.gov.cn/portal/download gongan_icon_url: since 可以显示页脚的建站信息，例如since: 2018，那么显示的就是@2018 ~ 今年 powered 设置为false可以关闭powered by hexo theme 设置为false可以关闭powered by next beian 如果备案了可以设置为true 版权信息12345678910# Creative Commons 4.0 International License.# See: https://creativecommons.org/share-your-work/licensing-types-examples# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.orgcreative_commons: license: by-nc-sa #设置版权标准 sidebar: true #是否在侧边栏显示版权信息 post: true #是否在文章底部显示版权信息 language: en #设置语言 版权标准信息可以去 Creative Commons 查看 GitHub角标 设置右上角的GitHub角标 12345# `Follow me on GitHub` banner in the top-right corner.github_banner: enable: #是否启用 permalink: #github地址 title: #显示的标题 菜单栏设置 设置菜单栏，如标签、分类、首页等栏目 12345678910111213141516171819# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.# Value before `||` delimiter is the target link.# Value after `||` delimiter is the name of Font Awesome icon. If icon (with or without delimiter) is not specified, question icon will be loaded.# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# External url should start with http:// or https://menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat ||前表示页面的地址，后面表示显示的图标名称about:用于设置关于页面，没有的话在Git bash中使用hexo new page &quot;about&quot;创建，然后打开\source\about\index.md就可以编写了tags:用于设置标签功能，同样使用命令hexo new page &quot;tags&quot;创建，然后打开source\tags\index.md并在日期后面添加一行type: &quot;tags&quot;，写博文时在顶部加上一栏tags: []即可设置标签，多个标签中间使用,分隔archieves:用于设置归档页面categories:用于设置目录页面，编辑博文时在顶部加上一栏categories:就可以为博文设置所属目录 Next 主题选择 Next 竟然还有主题… 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 根据喜好自行选择 侧边栏社交链接显示1234567891011121314151617# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimiter is the target permalink.# Value after `||` delimiter is the name of Font Awesome icon. If icon (with or without delimiter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/youname || github E-Mail: mailto:xxx@xxx.xxx || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 根据需要自行解锁即可 头像设置12345678910# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # If true, the avatar would be rotated with the cursor. rotated: true rounded 设置头像为圆形的 rotated 设置鼠标经过头像，头像自动旋转 url 头像位置 侧边栏设置1234567891011# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false # If true, all level of TOC in a post will be displayed, rather than the activated part of it. expand_all: false # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter. max_depth: 6 number 是否设置自动编号 wrap 当标题超出侧边栏的最大宽度的时候是否自动换行 expand_all 是否展开所有的标题 max_depth 生成目录的最大深度 123456789101112131415161718192021sidebar: # Sidebar Position. position: right #position: right # Manual define the sidebar width. If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 # Sidebar Display (only for Muse | Mist), available values: # - post expand on posts automatically. Default. # - always expand for all pages automatically. # - hide expand only when click on the sidebar toggle icon. # - remove totally remove sidebar including sidebar toggle. display: post # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false position 侧边栏的位置，默认是left onmobile 移动端显示是否开启侧边栏 阅读全文 默认第一篇文章是全部展开的，如果不希望一次全部展开，而是只显示一部分，那么可以设置阅读全文，只显示一小部分，点击 阅读全文 以后再查看详细内容 12345678910111213# Automatically excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.# 默认第一篇文章显示全文 设置文章未点开显示的字数 初始为falseauto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt section.read_more_btn: true# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true read_more_btn 是否显示阅读全文按钮 enable 设置开启阅读全文 length 设置显示的文字长度，也可以通过在文章里面添加 &lt;!-- more --&gt; 来告诉编译器显示到这里为止，不过如果要使用这个，就要设置scroll_to_more为true才行了 代码复制123456789101112codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright # See: https://github.com/chriskempson/tomorrow-theme highlight_theme: normal # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: highlight_theme 设置代码块高亮样式 enable 设置是否启用代码复制功能，默认是false show_result 设置点击了复制以后，是否提示复制成功与否 站内搜索开启搜索功能可以快速定位文章首先，在博客根目录下执行 1$ npm install hexo-generator-searchdb --save 然后修改主题_config.yml文件 12345678910111213# Local Search# Dependencies: https://github.com/wzpan/hexo-generator-searchlocal_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 设置enable为true就打开站内搜索啦 Next 主题美化 弄完上面的配置以后就可以用了，但是看着还是有点丑，继续深度美化一下 顶部阅读进度条 博客顶部有一根进度条显示阅读进度 首先到站点根目录下，添加一个包 1git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress 然后修改主题_config.yml文件 1234567# Reading progress barreading_progress: enable: true # Available values: top | bottom position: top color: "#ffc0cb" height: 2px enable 开启阅读进度条 position 进度条位置 color 进度条颜色 height 进度条粗细 站点加载条 载入文章时，顶部会有一个加载条 修改主题_config.yml配置文件 123456789# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pace# For more information: https://github.com/HubSpot/pacepace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: minimal 设置为enable为true即可打开加载条，其它加载条样式可以去 PACE 查看 设置动态背景修改主题_config.yml配置文件 1234567891011# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nest# For more information: https://github.com/hustcc/canvas-nest.js# 背景线条配置canvas_nest: enable: true #是否启用动态背景 onmobile: true #移动端是否显示动态背景 color: "0,0,255" #线条颜色 opacity: 0.5 #线条透明度 zIndex: -1 #设置为-1，让线条位于其它元素底部 count: 199 #线条数目 鼠标点击效果 特效有心形和爆炸两种效果，但是特效比较消耗性能，尤其是爆炸特效，慎用 心形特效1.创建js文件 在themes/next/source/js下新建一个clicklove.js，然后添加以下代码 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2.修改layout文件 打开themes/next/layout/_layout.swig文件，在&lt;/body&gt;之前添加以下代码 12&lt;!-- 页面点击心形 --&gt;&lt;script type="text/javascript" src="/js/clicklove.js"&gt;&lt;/script&gt; 爆炸特效1.创建js文件 在themes/next/source/js下创建名为firework.js的文件，并添加以下代码 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 2.修改layout文件 打开themes/next/layout/_layout.swig文件，在&lt;/body&gt;之前添加以下代码 1234&lt;!-- 爆炸效果 --&gt;&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/firework.js"&gt;&lt;/script&gt; 3.配置主题配置文件 修改主题_config.yml配置文件，在末尾添加 12# Fireworksfireworks: true Live2D看板娘（添加宠物）1.安装live2D模块 1npm install --save hexo-helper-live2d 2.选择喜欢的模型安装 1npm install --save &lt;喜欢的模块&gt; 这里有几个模块，在线演示 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 这里安装的是宠物狗 1npm install --save live2d-widget-model-wanko 2.安装好了以后，需要修改站点_config.xml配置文件，在末尾添加以下代码 12345678910111213141516171819# 宠物live2d: enable: true #启用宠物 scriptFrom: local #插件来源 pluginRootPath: live2dw/ #插件根目录 pluginJsPath: lib/ #插件JS库目录 pluginModelPath: assets/ #模型文件目录 tagMode: false #是否启用标签模式 debug: false #是否可以调试 model: use: live2d-widget-model-wanko #使用的模型 display: position: right #显示位置 width: 150 #宽度 height: 300 #高度 mobile: show: true #移动端是否显示 react: opacity: 1 #透明度 网站标题崩溃欺骗1.在themes/next/source/js/下创建crash_cheat.js文件，并添加以下代码 1234567891011121314151617&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好了~' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 第一个document.title就是第一次退出当前页面的时候显示的内容 第二个document.title就是回到页面的时候显示的内容 注意把第二个ico路径改成自己的ico路径，否则回来的时候还是显示崩溃的ico 2.在themes/next/layout/_layout.swig末尾添加以下代码 12&lt;!--崩溃欺骗--&gt;&lt;script type="text/javascript" src="/js/crash_cheat.js"&gt;&lt;/script&gt; 修改文章底部标签样式 默认的标签样式是#，不是很好看 修改themes/next/layout/_macro/post.swig，找到rel=&quot;tags&quot;，需要把中间的内容替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文章尾部添加结束标记1.在themes/next/layout/_macro/下创建一个文件passage-end-tag.swig，并添加以下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;----------------------------------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读----------------------------------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 2.在themes/next/layout/_macro/post.swig的post-body之后，post-footer之前添加以下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 3.修改主题_config.yml配置文件，在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 网站运行时间修改themes/next/layout/_partials/footer.swig文件，添加以下代码 12345678910111213141516171819&lt;div&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("03/31/2019 00:00:00"); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125;setInterval("createtime()",250);&lt;/script&gt;&lt;/div&gt; 字数统计和阅读时长统计1.安装插件 1npm install hexo-symbols-count-time --save 2.修改站点_config.yml配置文件，加入以下代码 1234567# 文章统计symbols_count_time: symbols: true #统计文章字数 time: true #估算阅读时间 total_symbols: true #统计所有文章子树 total_time: true #估算所有文章阅读时长 exclude_codeblock: false #排除代码块 3.修改主题_config.yml配置文件，找到symbols_count_time，修改为 123456789# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 suffix: mins. 文章加密访问 文章加密访问可能会对字数统计、目录生成功能产生冲突，比如导致数据错乱和没有目录的情况发生，根据需要选择使用 1.插件安装 1npm install --save hexo-blog-encrypt 2.配置站点_config.yml配置文件，找到encrypt，修改为 1234# Security##encrypt: enable: true 3.使用 在文章头部加入password、message、abstract字段即可 12345678---title: hexodate: 2019-08-28 19:00:00categories: Blogpassword: 123456abstract: 文章已加密message: 请输入密码--- password就是访问密码 abstract就是显示的摘要信息 message就是密码输入框需要显示的信息 文章置顶1.插件安装 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 2.修改themes/next/layout/_macro/post.swig文件，找到&lt;div class=&quot;post-meta&quot;&gt;，在里面添加以下代码 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color="7D26CD"&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125; 3.使用 在需要置顶的文章加入属性top 123456---title: hexodate: 2019-05-02 19:00:00categories: Blogtop: true---]]></content>
      <categories>
        <category>theme</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>theme</tag>
        <tag>美化</tag>
      </tags>
  </entry>
</search>
